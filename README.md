# gomokuAI

This is a program that performs Minimax search and alpha beta pruning in order to win in a game of Gomoku, or Five in a Row.
  
## ARCHITECTURE:
The underlying data structure for the board is a 2D vector of integers. It takes as an input two flags, one for choosing whether the AI goes first in the game and one for determining the board size. After initializing the board, the player and AI take turns deciding moves, with the player inputting coordinates for board location. The AI decides its best move based on a Minimax search on each possible open space. The board’s index based on 2D coordinate is marked with 1 if the AI places a piece in a spot, 2 if the player places a piece in a spot, and -1 if the spot is open.

## SEARCH:
As briefly mentioned before, the AI uses a Minimax search algorithm to search for the best move to make. In this algorithm, a series of moves are simulated and scored. Higher scores represent actions that mean the AI is closer to winning and lower scores mean the player is closer to winning. The algorithm makes moves that maximize the score at a given moment when simulating the AI, while minimizing the score at a given moment when simulating the player, ultimately choosing the action that leads to the highest score when assuming the opponent plays moves that are ideal for their own success. The number of moves simulated depends on a set depth. At a lower level, the Minimax is implemented by a set of for loops that identify possible moves that can be made at a given time. It takes as an input a bool to determine which player it is simulating and whether it needs to find the move with that will maximize or minimize score. At each simulation of a move, the function is recursively called again with the bool flipped and the depth incremented in order to simulate a move for the opposing side. When the previously set MAX_DEPTH is reached, the function hits the base case and returns the score for the state after the simulated moves. The score is calculated by analyzing the state of the board after the given series of moves. A heuristic evaluation function recognizes patterns for both the player’s pieces and the AI’s pieces. Checking horizontally, vertically, diagonally from left to right, and diagonally from right to left, sets of consecutive pieces are identified having a higher scoring weight the closer it is to being 5 in a row. The weights increase at least exponentially so that certain moves outweigh others. For instance, if a move has the potential to become five in a row, it is weighed much higher so that the algorithm always chooses that move over creating a smaller set. In addition, the number of open ends is identified around each set, with two open ends having more weight and no open ends having no weight as it cannot become a win. Another example is that a set of four with two open ends is equivalent to a win. Ultimately, the score for the state is given by the score of the state of AI pieces subtracted by the score of the state of player pieces, so that the AI is doing better if the score is higher and the player is doing better if the score is lower. To prevent the algorithm from choosing the move that helps the AI rather than defending from the player, threats (sets) from the player are weighed more heavily than their AI scoring function counterpart. This way the Minimax will end up choosing a move that will prevent the player from becoming threatening. Unfortunately, since the Minimax algorithm has to check all possible next moves for each move simulated, the branching factor of the algorithm is very high. This causes the algorithm to run very slowly. In order to counteract this, alpha-beta pruning is done to reduce the amount of moves that need to be checked. In addition to the other parameters passed into the Minimax function, and an alpha and beta are also passed in with beta representing the best score a Minimizer depth is assured of thus far and an alpha representing the best score a Maximizer depth is assured of thus far. Thus the values chosen for a max must be lower than the lowest value thus far for a previous minimum and the values chosen for a min must be higher than the highest value for a previous maximum. If the alpha exceeds the beta for a move, the rest of the moves from that point do not need to be considered because a previous minimizer or maximizer would prevent it from reaching those values. Finally, in order to counteract early moves having to search for more possible moves at each depth, the MAX_DEPTH increases to 2 only after 5 moves have been placed.

## CHALLENGES:
A challenge I faced was that the AI decider was at times not trying to prevent the player from placing a fifth tile to get five in a row after having a chain of four. I noticed that on most of these occasions, they occurred when there was a chain of four going from left to right diagonally. From there I realized that my check for diagonal sets was not iterating over the diagonals from left to right properly and thus never noticed when a set occurred. After rewriting how to generate the right indices it started to detect these diagonals and stop the four chain. I also increased the weight for the opponents chains compared to the AI so that defense would be more important than offense so that the AI would not choose to attack when an impending threat is there. I also struggled to choose the scores for the weightage as making them to close would lead to the decider at times choosing not to extend a chain compared to making a new one. To fix this I made each weightage scale exponentially to decrease the likelihood of this occurring.4.

## WEAKNESSES:
One large weakness my implementation has is that it does not detect patterns that have holes between them. For instance a tile, a gap, and then a chain of two is seen as relatively low scoring, as a chain of two plus a chain of one is still lower than a chain of open ended three, but both can easily become an open ended chain of four which would result in a win. In order to potentially fix this, a new heuristic can be made that can recognize certain patterns not based on consecutive tiles, applying a score based on the pattern instead.

